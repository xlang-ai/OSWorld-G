{
  "name": "autocomplete",
  "introduction": [
    "# Autocomplete\n\n<p class=\"description\">The autocomplete is a normal text input enhanced by a panel of suggested options.</p>\n\nThe widget is useful for setting the value of a single-line textbox in one of two types of scenarios:\n\n1. The value for the textbox must be chosen from a predefined set of allowed values, for example a location field must contain a valid location name: [combo box](#combo-box).\n2. The textbox may contain any arbitrary value, but it is advantageous to suggest possible values to the user, for example a search field may suggest similar or previous searches to save the user time: [free solo](#free-solo).\n\nIt's meant to be an improved version of the \"react-select\" and \"downshift\" packages."
  ],
  "code_path": [
    null
  ],
  "children": [
    {
      "name": "Combo box",
      "introduction": [
        "Combo box\n\nThe value must be chosen from a predefined set of allowed values."
      ],
      "code_path": [
        "ComboBox.js"
      ],
      "children": [
        {
          "name": "Options structure",
          "introduction": [
            "Options structure\n\nBy default, the component accepts the following options structures:\n\n```ts\ninterface AutocompleteOption {\n  label: string;\n}\n// or\ntype AutocompleteOption = string;\n```\n\nfor instance:\n\n```js\nconst options = [\n  { label: 'The Godfather', id: 1 },\n  { label: 'Pulp Fiction', id: 2 },\n];\n// or\nconst options = ['The Godfather', 'Pulp Fiction'];\n```\n\nHowever, you can use different structures by providing a `getOptionLabel` prop.\n\nIf your options are objects, you must provide the `isOptionEqualToValue` prop to ensure correct selection and highlighting. By default, it uses strict equality to compare options with the current value."
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "Playground",
          "introduction": [
            "Playground\n\nEach of the following examples demonstrates one feature of the Autocomplete component."
          ],
          "code_path": [
            "Playground.js"
          ],
          "children": []
        },
        {
          "name": "Country select",
          "introduction": [
            "Country select\n\nChoose one of the 248 countries."
          ],
          "code_path": [
            "CountrySelect.js"
          ],
          "children": []
        },
        {
          "name": "Controlled states",
          "introduction": [
            "Controlled states\n\nThe component has two states that can be controlled:\n\n1. the \"value\" state with the `value`/`onChange` props combination. This state represents the value selected by the user, for instance when pressing <kbd class=\"key\">Enter</kbd>.\n2. the \"input value\" state with the `inputValue`/`onInputChange` props combination. This state represents the value displayed in the textbox.\n\nThese two states are isolated, and should be controlled independently.\n\n:::info\n\n- A component is **controlled** when it's managed by its parent using props.\n- A component is **uncontrolled** when it's managed by its own local state.\n\nLearn more about controlled and uncontrolled components in the [React documentation](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components).\n:::",
            ":::warning\n\nIf you control the `value`, make sure it's referentially stable between renders.\nIn other words, the reference to the value shouldn't change if the value itself doesn't change.\n\n```tsx\n// ‚ö†Ô∏è BAD\nreturn <Autocomplete multiple value={allValues.filter((v) => v.selected)} />;\n\n// üëç GOOD\nconst selectedValues = React.useMemo(\n  () => allValues.filter((v) => v.selected),\n  [allValues],\n);\nreturn <Autocomplete multiple value={selectedValues} />;\n```\n\nIn the first example, `allValues.filter` is called and returns **a new array** every render.\nThe fix includes memoizing the value, so it changes only when needed.\n:::"
          ],
          "code_path": [
            "ControllableStates.js",
            null
          ],
          "children": []
        }
      ]
    },
    {
      "name": "Free solo",
      "introduction": [
        "Free solo\n\nSet `freeSolo` to true so the textbox can contain any arbitrary value."
      ],
      "code_path": [
        null
      ],
      "children": [
        {
          "name": "Search input",
          "introduction": [
            "Search input\n\nThe prop is designed to cover the primary use case of a **search input** with suggestions, for example Google search or react-autowhatever.",
            ":::warning\nBe careful when using the free solo mode with non-string options, as it may cause type mismatch.\n\nThe value created by typing into the textbox is always a string, regardless of the type of the options.\n:::"
          ],
          "code_path": [
            "FreeSolo.js",
            null
          ],
          "children": []
        },
        {
          "name": "Creatable",
          "introduction": [
            "Creatable\n\nIf you intend to use this mode for a [combo box](#combo-box) like experience (an enhanced version of a select element) we recommend setting:\n\n- `selectOnFocus` to help the user clear the selected value.\n- `clearOnBlur` to help the user enter a new value.\n- `handleHomeEndKeys` to move focus inside the popup with the <kbd class=\"key\">Home</kbd> and <kbd class=\"key\">End</kbd> keys.\n- A last option, for instance: `Add \"YOUR SEARCH\"`.",
            "You could also display a dialog when the user wants to add a new value."
          ],
          "code_path": [
            "FreeSoloCreateOption.js",
            "FreeSoloCreateOptionDialog.js"
          ],
          "children": []
        }
      ]
    },
    {
      "name": "Grouped",
      "introduction": [
        "Grouped\n\nYou can group the options with the `groupBy` prop.\nIf you do so, make sure that the options are also sorted with the same dimension that they are grouped by,\notherwise, you will notice duplicate headers.",
        "To control how the groups are rendered, provide a custom `renderGroup` prop.\nThis is a function that accepts an object with two fields:\n\n- `group`‚Äîa string representing a group name\n- `children`‚Äîa collection of list items that belong to the group\n\nThe following demo shows how to use this prop to define custom markup and override the styles of the default groups:"
      ],
      "code_path": [
        "Grouped.js",
        "RenderGroup.js"
      ],
      "children": []
    },
    {
      "name": "Disabled options",
      "introduction": [
        "Disabled options"
      ],
      "code_path": [
        "DisabledOptions.js"
      ],
      "children": []
    },
    {
      "name": "`useAutocomplete`",
      "introduction": [
        "`useAutocomplete`\n\nFor advanced customization use cases, a headless `useAutocomplete()` hook is exposed.\nIt accepts almost the same options as the Autocomplete component minus all the props\nrelated to the rendering of JSX.\nThe Autocomplete component is built on this hook.\n\n```tsx\nimport { useAutocomplete } from '@mui/base/useAutocomplete';\n```\n\nThe `useAutocomplete` hook is also reexported from @mui/material for convenience and backward compatibility.\n\n```tsx\nimport useAutocomplete from '@mui/material/useAutocomplete';\n```\n\n- üì¶ [4.6 kB gzipped](https://bundlephobia.com/package/@mui/material)."
      ],
      "code_path": [
        "UseAutocomplete.js"
      ],
      "children": [
        {
          "name": "Customized hook",
          "introduction": [
            "Customized hook",
            "Head to the [customization](#customization) section for an example with the `Autocomplete` component instead of the hook."
          ],
          "code_path": [
            "CustomizedHook.js",
            null
          ],
          "children": []
        }
      ]
    },
    {
      "name": "Asynchronous requests",
      "introduction": [
        "Asynchronous requests\n\nThe component supports two different asynchronous use-cases:\n\n- [Load on open](#load-on-open): it waits for the component to be interacted with to load the options.\n- [Search as you type](#search-as-you-type): a new request is made for each keystroke."
      ],
      "code_path": [
        null
      ],
      "children": [
        {
          "name": "Load on open",
          "introduction": [
            "Load on open\n\nIt displays a progress state as long as the network request is pending."
          ],
          "code_path": [
            "Asynchronous.js"
          ],
          "children": []
        },
        {
          "name": "Search as you type",
          "introduction": [
            "Search as you type\n\nIf your logic is fetching new options on each keystroke and using the current value of the textbox\nto filter on the server, you may want to consider throttling requests.\n\nAdditionally, you will need to disable the built-in filtering of the `Autocomplete` component by\noverriding the `filterOptions` prop:\n\n```jsx\n<Autocomplete filterOptions={(x) => x} />\n```"
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "Google Maps place",
          "introduction": [
            "Google Maps place\n\nA customized UI for Google Maps Places Autocomplete.\nFor this demo, we need to load the [Google Maps JavaScript](https://developers.google.com/maps/documentation/javascript/overview) and [Google Places](https://developers.google.com/maps/documentation/places/web-service/overview) API.\n\n:::info\nThe following demo relies on [autosuggest-highlight](https://github.com/moroshko/autosuggest-highlight), a small (1 kB) utility for highlighting text in autosuggest and autocomplete components.\n:::",
            ":::error\nBefore you can start using the Google Maps JavaScript API and Places API, you need to get your own [API key](https://developers.google.com/maps/documentation/javascript/get-api-key).\n:::"
          ],
          "code_path": [
            "GoogleMaps.js",
            null
          ],
          "children": []
        }
      ]
    },
    {
      "name": "Multiple values",
      "introduction": [
        "Multiple values\n\nAlso known as tags, the user is allowed to enter more than one value."
      ],
      "code_path": [
        "Tags.js"
      ],
      "children": [
        {
          "name": "Fixed options",
          "introduction": [
            "Fixed options\n\nIn the event that you need to lock certain tags so that they can't be removed, you can set the chips disabled."
          ],
          "code_path": [
            "FixedTags.js"
          ],
          "children": []
        },
        {
          "name": "Checkboxes",
          "introduction": [
            "Checkboxes"
          ],
          "code_path": [
            "CheckboxesTags.js"
          ],
          "children": []
        },
        {
          "name": "Limit tags",
          "introduction": [
            "Limit tags\n\nYou can use the `limitTags` prop to limit the number of displayed options when not focused."
          ],
          "code_path": [
            "LimitTags.js"
          ],
          "children": []
        }
      ]
    },
    {
      "name": "Sizes",
      "introduction": [
        "Sizes\n\nFancy smaller inputs? Use the `size` prop."
      ],
      "code_path": [
        "Sizes.js"
      ],
      "children": []
    },
    {
      "name": "Customization",
      "introduction": [
        "Customization"
      ],
      "code_path": [
        null
      ],
      "children": [
        {
          "name": "Custom input",
          "introduction": [
            "Custom input\n\nThe `renderInput` prop allows you to customize the rendered input.\nThe first argument of this render prop contains props that you need to forward.\nPay specific attention to the `ref` and `inputProps` keys.\n\n:::warning\nIf you're using a custom input component inside the Autocomplete, make sure that you forward the ref to the underlying DOM element.\n:::"
          ],
          "code_path": [
            "CustomInputAutocomplete.js"
          ],
          "children": []
        },
        {
          "name": "Globally Customized Options",
          "introduction": [
            "Globally Customized Options\n\nTo globally customize the Autocomplete options for all components in your app,\nyou can use the [theme default props](/material-ui/customization/theme-components/#theme-default-props) and set the `renderOption` property in the `defaultProps` key.\nThe `renderOption` property takes the `ownerState` as the fourth parameter, which includes props and internal component state.\nTo display the label, you can use the `getOptionLabel` prop from the `ownerState`.\nThis approach enables different options for each Autocomplete component while keeping the options styling consistent."
          ],
          "code_path": [
            "GloballyCustomizedOptions.js"
          ],
          "children": []
        },
        {
          "name": "GitHub's picker",
          "introduction": [
            "GitHub's picker\n\nThis demo reproduces GitHub's label picker:",
            "Head to the [Customized hook](#customized-hook) section for a customization example with the `useAutocomplete` hook instead of the component."
          ],
          "code_path": [
            "GitHubLabel.js",
            null
          ],
          "children": []
        },
        {
          "name": "Hint",
          "introduction": [
            "Hint\n\nThe following demo shows how to add a hint feature to the Autocomplete:"
          ],
          "code_path": [
            "AutocompleteHint.js"
          ],
          "children": []
        }
      ]
    },
    {
      "name": "Highlights",
      "introduction": [
        "Highlights\n\nThe following demo relies on [autosuggest-highlight](https://github.com/moroshko/autosuggest-highlight), a small (1 kB) utility for highlighting text in autosuggest and autocomplete components."
      ],
      "code_path": [
        "Highlights.js"
      ],
      "children": []
    },
    {
      "name": "Custom filter",
      "introduction": [
        "Custom filter\n\nThe component exposes a factory to create a filter method that can be provided to the `filterOptions` prop.\nYou can use it to change the default option filter behavior.\n\n```js\nimport { createFilterOptions } from '@mui/material/Autocomplete';\n```"
      ],
      "code_path": [
        null
      ],
      "children": [
        {
          "name": "`createFilterOptions(config) => filterOptions`",
          "introduction": [
            "`createFilterOptions(config) => filterOptions`"
          ],
          "code_path": [
            null
          ],
          "children": [
            {
              "name": "Arguments",
              "introduction": [
                "Arguments\n\n1. `config` (_object_ [optional]):\n\n- `config.ignoreAccents` (_bool_ [optional]): Defaults to `true`. Remove diacritics.\n- `config.ignoreCase` (_bool_ [optional]): Defaults to `true`. Lowercase everything.\n- `config.limit` (_number_ [optional]): Default to null. Limit the number of suggested options to be shown. For example, if `config.limit` is `100`, only the first `100` matching options are shown. It can be useful if a lot of options match and virtualization wasn't set up.\n- `config.matchFrom` (_'any' | 'start'_ [optional]): Defaults to `'any'`.\n- `config.stringify` (_func_ [optional]): Controls how an option is converted into a string so that it can be matched against the input text fragment.\n- `config.trim` (_bool_ [optional]): Defaults to `false`. Remove trailing spaces."
              ],
              "code_path": [
                null
              ],
              "children": []
            },
            {
              "name": "Returns",
              "introduction": [
                "Returns\n\n`filterOptions`: the returned filter method can be provided directly to the `filterOptions` prop of the `Autocomplete` component, or the parameter of the same name for the hook.\n\nIn the following demo, the options need to start with the query prefix:\n\n```jsx\nconst filterOptions = createFilterOptions({\n  matchFrom: 'start',\n  stringify: (option) => option.title,\n});\n\n<Autocomplete filterOptions={filterOptions} />;\n```"
              ],
              "code_path": [
                "Filter.js"
              ],
              "children": []
            }
          ]
        },
        {
          "name": "Advanced",
          "introduction": [
            "Advanced\n\nFor richer filtering mechanisms, like fuzzy matching, it's recommended to look at [match-sorter](https://github.com/kentcdodds/match-sorter). For instance:\n\n```jsx\nimport { matchSorter } from 'match-sorter';\n\nconst filterOptions = (options, { inputValue }) => matchSorter(options, inputValue);\n\n<Autocomplete filterOptions={filterOptions} />;\n```"
          ],
          "code_path": [
            null
          ],
          "children": []
        }
      ]
    },
    {
      "name": "Virtualization",
      "introduction": [
        "Virtualization\n\nSearch within 10,000 randomly generated options. The list is virtualized thanks to [react-window](https://github.com/bvaughn/react-window)."
      ],
      "code_path": [
        "Virtualize.js"
      ],
      "children": []
    },
    {
      "name": "Events",
      "introduction": [
        "Events\n\nIf you would like to prevent the default key handler behavior, you can set the event's `defaultMuiPrevented` property to `true`:\n\n```jsx\n<Autocomplete\n  onKeyDown={(event) => {\n    if (event.key === 'Enter') {\n      // Prevent's default 'Enter' behavior.\n      event.defaultMuiPrevented = true;\n      // your handler code\n    }\n  }}\n/>\n```"
      ],
      "code_path": [
        null
      ],
      "children": []
    },
    {
      "name": "Limitations",
      "introduction": [
        "Limitations"
      ],
      "code_path": [
        null
      ],
      "children": [
        {
          "name": "autocomplete/autofill",
          "introduction": [
            "autocomplete/autofill\n\nBrowsers have heuristics to help the user fill in form inputs.\nHowever, this can harm the UX of the component.\n\nBy default, the component disables the input **autocomplete** feature (remembering what the user has typed for a given field in a previous session) with the `autoComplete=\"off\"` attribute.\nGoogle Chrome does not currently support this attribute setting ([Issue 41239842](https://issues.chromium.org/issues/41239842)).\nA possible workaround is to remove the `id` to have the component generate a random one.\n\nIn addition to remembering past entered values, the browser might also propose **autofill** suggestions (saved login, address, or payment details).\nIn the event you want the avoid autofill, you can try the following:\n\n- Name the input without leaking any information the browser can use. For example `id=\"field1\"` instead of `id=\"country\"`. If you leave the id empty, the component uses a random id.\n- Set `autoComplete=\"new-password\"` (some browsers will suggest a strong password for inputs with this attribute setting):\n\n  ```jsx\n  <TextField\n    {...params}\n    inputProps={{\n      ...params.inputProps,\n      autoComplete: 'new-password',\n    }}\n  />\n  ```\n\nRead [the guide on MDN](https://developer.mozilla.org/en-US/docs/Web/Security/Practical_implementation_guides/Turning_off_form_autocompletion) for more details."
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "iOS VoiceOver",
          "introduction": [
            "iOS VoiceOver\n\nVoiceOver on iOS Safari doesn't support the `aria-owns` attribute very well.\nYou can work around the issue with the `disablePortal` prop."
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "ListboxComponent",
          "introduction": [
            "ListboxComponent\n\nIf you provide a custom `ListboxComponent` prop, you need to make sure that the intended scroll container has the `role` attribute set to `listbox`. This ensures the correct behavior of the scroll, for example when using the keyboard to navigate."
          ],
          "code_path": [
            null
          ],
          "children": []
        }
      ]
    },
    {
      "name": "Accessibility",
      "introduction": [
        "Accessibility\n\n(WAI-ARIA: https://www.w3.org/WAI/ARIA/apg/patterns/combobox/)\n\nWe encourage the usage of a label for the textbox.\nThe component implements the WAI-ARIA authoring practices."
      ],
      "code_path": [
        null
      ],
      "children": []
    }
  ]
}