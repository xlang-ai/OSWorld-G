{
  "name": "row-updates",
  "introduction": [
    "# Data Grid - Row updates\n\n<p class=\"description\">Always keep your rows up to date.</p>"
  ],
  "code_path": [
    null
  ],
  "children": [
    {
      "name": "The `rows` prop",
      "introduction": [
        "The `rows` prop\n\nThe simplest way to update the rows is to provide the new rows using the `rows` prop.\nIt replaces the previous values. This approach has some drawbacks:\n\n- You need to provide all the rows.\n- You might create a performance bottleneck when preparing the rows array to provide to the Data Grid.",
        ":::warning\nUpdating the `rows` prop causes the Data Grid to recompute the row tree, resulting in losing the current tree information like the expanded rows state.\nUnless the recomputation is explicitly required, the API method `updateRows()` should be used.\n:::"
      ],
      "code_path": [
        "UpdateRowsProp.js",
        null
      ],
      "children": []
    },
    {
      "name": "The `updateRows()` method",
      "introduction": [
        "The `updateRows()` method\n\nIf you want to only update part of the rows, you can use the `apiRef.current.updateRows()` method.",
        "The default behavior of `updateRows()` API is to upsert rows.\nSo if a row has an id that is not in the current list of rows then it will be added to the Data Grid.\n\nAlternatively, if you would like to delete a row, you would need to pass an extra `_action` property in the update object as below.\n\n```ts\napiRef.current.updateRows([{ id: 1, _action: 'delete' }]);\n```\n\n:::info\nThe community version of the Data Grid is limited to a single row update per `apiRef.current.updateRows()` call.\nMultiple row updates at a time are supported in [Pro](/x/introduction/licensing/#pro-plan) and [Premium](/x/introduction/licensing/#premium-plan) plans.\n:::"
      ],
      "code_path": [
        "UpdateRowsApiRef.js",
        null
      ],
      "children": []
    },
    {
      "name": "Infinite loading [<span class=\"plan-pro\"></span>](/x/introduction/licensing/#pro-plan 'Pro plan')",
      "introduction": [
        "Infinite loading [<span class=\"plan-pro\"></span>](/x/introduction/licensing/#pro-plan 'Pro plan')\n\nThe grid provides a `onRowsScrollEnd` prop that can be used to load additional rows when the scroll reaches the bottom of the viewport area.\n\nIn addition, the area in which `onRowsScrollEnd` is called can be changed using `scrollEndThreshold`.",
        ":::info\nFor sorting and filtering to work properly with the infinite loading, they should be applied on the server-side.\nOtherwise, the sorting and filtering will only be applied to the subset of rows that have been loaded.\n:::"
      ],
      "code_path": [
        "InfiniteLoadingGrid.js",
        null
      ],
      "children": []
    },
    {
      "name": "Lazy loading [<span class=\"plan-pro\"></span>](/x/introduction/licensing/#pro-plan 'Pro plan')",
      "introduction": [
        "Lazy loading [<span class=\"plan-pro\"></span>](/x/introduction/licensing/#pro-plan 'Pro plan')\n\nLazy Loading works like a pagination system, but instead of loading new rows based on pages, it loads them based on the viewport.\nIt loads new rows in chunks, as the user scrolls through the Data Grid and reveals empty rows.\n\nThe Data Grid builds the vertical scroll as if all the rows are already there, and displays empty (skeleton) rows while loading the data. Only rows that are displayed get fetched.\n\nTo enable lazy loading, there are a few steps you need to follow:\n\nFirst, set `rowsLoadingMode=\"server\"`.\nThen, set `rowCount` to reflect the number of available rows on the server.\nThird, set a callback function on `onFetchRows` to load the data corresponding to the row indices passed within `GridFetchRowsParams`.\nFinally, replace the empty rows with the newly fetched ones using `apiRef.current.unstable_replaceRows()` like in the demo below.",
        ":::warning\nThe `onFetchRows` callback is called every time a new row is in the viewport, so when you scroll, you can easily send multiple requests to your backend. We recommend developers limit those by implementing debouncing.\n:::\n\n:::warning\nFor now, lazy loading rows does not work with row grouping or tree data.\n:::\n\n:::info\nIn order for filtering and sorting to work you need to set their modes to `server`.\nYou can find out more information about how to do that on the [server-side filter page](/x/react-data-grid/filtering/server-side/) and on the [server-side sorting page](/x/react-data-grid/sorting/#server-side-sorting).\n:::"
      ],
      "code_path": [
        "LazyLoadingGrid.js",
        null
      ],
      "children": []
    },
    {
      "name": "High frequency [<span class=\"plan-pro\"></span>](/x/introduction/licensing/#pro-plan 'Pro plan')",
      "introduction": [
        "High frequency [<span class=\"plan-pro\"></span>](/x/introduction/licensing/#pro-plan 'Pro plan')\n\nWhenever the rows are updated, the Data Grid has to apply the sorting and filters. This can be a problem if you have high frequency updates. To maintain good performances, the Data Grid allows to batch the updates and only apply them after a period of time. The `throttleRowsMs` prop can be used to define the frequency (in milliseconds) at which rows updates are applied.\n\nWhen receiving updates more frequently than this threshold, the Data Grid will wait before updating the rows.\n\nThe following demo updates the rows every 10 ms, but they are only applied every 2 seconds."
      ],
      "code_path": [
        "ThrottledRowsGrid.js"
      ],
      "children": []
    },
    {
      "name": "API",
      "introduction": [
        "API\n\n- [DataGrid](/x/api/data-grid/data-grid/)\n- [DataGridPro](/x/api/data-grid/data-grid-pro/)\n- [DataGridPremium](/x/api/data-grid/data-grid-premium/)"
      ],
      "code_path": [
        null
      ],
      "children": []
    }
  ]
}