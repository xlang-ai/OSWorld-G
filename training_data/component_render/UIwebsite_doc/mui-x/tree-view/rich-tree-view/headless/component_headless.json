{
  "name": "headless",
  "introduction": [
    "# Rich Tree View - Headless\n\n<p class=\"description\">Create your custom Tree View.</p>\n\n:::warning\nThe `useTreeView` hook is not public API for now,\nthis page is still a _Work in Progress_ and its content is not meant to be used in production.\n:::"
  ],
  "code_path": [
    null
  ],
  "children": [
    {
      "name": "Create a custom plugin",
      "introduction": [
        "Create a custom plugin"
      ],
      "code_path": [
        null
      ],
      "children": [
        {
          "name": "Basic plugin",
          "introduction": [
            "Basic plugin\n\nA custom plugins contains 2 required elements:\n\n1. A hook that will be executed by the `useTreeView` hook:\n\n   ```ts\n   const useCustomPlugin = ({ params }) => {\n     React.useEffect(() => {\n       console.log(params.customParam);\n     });\n\n     return {};\n   };\n   ```\n\n2. A property containing the params used by this topic:\n\n   ```ts\n   useCustomPlugin.params = {\n     customParam: true,\n   };\n   ```"
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "Params default value",
          "introduction": [
            "Params default value\n\nUse the `getDefaultizedParams` property to set a default value to your plugin params:\n\n```ts\nconst useCustomPlugin = ({ params }) => {\n  React.useEffect(() => {\n    console.log(params.customParam);\n  });\n\n  return {};\n};\n\nuseCustomPlugin.params = { customParam: true };\n\nuseCustomPlugin.getDefaultizedParams = ({ params }) => ({\n  ...params,\n  customParam: params.customParam ?? false,\n});\n```"
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "Controllable models",
          "introduction": [
            "Controllable models\n\nA model is a value that can either be controlled or initialized using a prop.\nThe Tree View contains several models like the `expandedItems` model which contains the ids of the items currently expanded.\n\nYou can create your own models using the `models` property of your plugin:\n\n```ts\nuseCustomPlugin.params = {\n  // ...other params\n  defaultCustomModel: true,\n  customModel: true,\n};\n\nuseCustomPlugin.getDefaultizedParams = ({ params }) => ({\n  ...params,\n  // ... other defaultized params\n  defaultCustomModel: params.defaultCustomModel ?? false,\n});\n\nuseCustomPlugin.models = {\n  customModel: {\n    getDefaultValue: (params) => defaultCustomModel,\n  },\n};\n```\n\n:::info\nWhen creating a model, you should always set a default value to your `defaultCustomModel` prop. This will initialize the component's internal state when the model is uncontrolled.\nSee the [Params default value](/x/react-tree-view/rich-tree-view/headless/#params-default-value) section for more information.\n:::\n\nYou can then use this model in your plugin (or in any other plugin) using the `models` parameter:\n\n```ts\nconst useCustomPlugin = ({ models }) => {\n  React.useEffect(() => {\n    console.log(models.customModel.value);\n  });\n\n  const updateCustomModel = (newValue) =>\n    models.customModel.setControlledValue(newValue);\n\n  return {};\n};\n```"
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "Use elements from another plugin",
          "introduction": [
            "Use elements from another plugin\n\nYour plugin can access the instance methods, the params and the models of any other plugin.\n\n```ts\nconst useCustomPlugin = ({ models }) => {\n  const handleSomeAction = () => {\n    // Log the id of the items currently expanded\n    console.log(models.expandedItems.value);\n\n    // Collapse all the items\n    models.expandedItems.setValue([]);\n\n    // Check if an item is expanded\n    const isExpanded = useSelector(selectorIsItemExpanded, 'some-item-id');\n  };\n};\n```\n\n:::warning\nSetting a model value in another plugin is wrong because it won't publish the associated callback.\nWe probably need a new abstraction here so that a plugin is always responsible for its model updates.\n:::"
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "Define a plugin state",
          "introduction": [
            "Define a plugin state\n\nTODO\n\n:::warning\nOnce `focusedItemId` becomes a model, we could consider removing the notion of state and just let each plugin define its state and provide methods in the instance to access / update it.\n:::"
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "Populate the Tree View instance",
          "introduction": [
            "Populate the Tree View instance\n\nThe Tree View instance is an object accessible in all the plugins and in the Tree Item.\nIt is the main way a plugin can provide features to the rest of the component.\n\n```ts\nconst useCustomPlugin = ({ models }) => {\n  const toggleCustomModel = () =>\n    models.customModel.setValue(!models.customModel.value);\n\n  return {\n    instance: {\n      toggleCustomModel,\n    },\n  };\n};\n```\n\nYou can then use this instance method in any other plugin:\n\n```ts\nconst useOtherCustomPlugin = ({ models, instance }) => {\n  const handleSomeAction = () => {\n    instance.toggleCustomModel();\n  };\n};\n```"
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "Emit and receive events",
          "introduction": [
            "Emit and receive events\n\n```ts\nconst useCustomPlugin = () => {\n  const toggleCustomModel = () => {\n    const newValue = !models.customModel.value;\n    models.customModel.setValue(newValue);\n    publishTreeViewEvent(instance, 'toggleCustomModel', { value: newValue });\n  };\n\n  return {\n    instance: {\n      toggleCustomModel,\n    },\n  };\n};\n```\n\nYou can then subscribe to this event in any other plugin:\n\n```ts\nconst useOtherCustomPlugin = ({ instance }) => {\n  useInstanceEventHandler(instance, 'toggleCustomModel', ({ value }) => {\n    console.log('New value of customModel', value);\n  });\n};\n```\n\n:::info\nIf you are using TypeScript, you need to define your dependencies in your plugin signature, see the [Plugin typing](/x/react-tree-view/rich-tree-view/headless/#plugin-typing) section for more information.\n:::"
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "Pass props to your root element",
          "introduction": [
            "Pass props to your root element\n\nUse the `getRootProps` property of your returned value to pass props to your root element:\n\n```ts\nconst useCustomPlugin = ({ params }) => {\n  return {\n    getRootProps: () => ({\n      'data-customparam': params.customParam,\n    }),\n  };\n};\n```"
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "Pass elements to the Tree Item",
          "introduction": [
            "Pass elements to the Tree Item\n\nUse the `contextValue` property in the returned object to pass elements to the Tree Item:\n\n:::warning\nThe context is private for now and cannot be accessed outside the provided plugins.\nYou need to modify the `useTreeItemState` hook to return the new value returned by your plugin.\n:::\n\n```tsx\nconst useCustomPlugin = ({ params }) => {\n  return {\n    contextValue: () => ({\n      customPlugin: { enabled: true },\n    }),\n  };\n};\n\nfunction useTreeItemState(itemId: string) {\n  const {\n    customPlugin,\n    // ...other elements returned by the context\n  } = useTreeViewContext<DefaultTreeViewPluginSignatures>();\n\n  // ...rest of the `useTreeItemState` hook content\n\n  return {\n    customPlugin,\n    // ...other elements returned by `useTreeItemState`\n  };\n}\n\nfunction TreeItemContent() {\n  const {\n    customPlugin,\n    // ...other elements returned by `useTreeItemState`\n  } = useTreeItemState(props.itemId);\n\n  // Do something with customPlugin.enabled\n}\n```"
          ],
          "code_path": [
            null
          ],
          "children": []
        },
        {
          "name": "Plugin typing",
          "introduction": [
            "Plugin typing\n\nThe typing of a plugin is defined using its _signature_.\nThis type contains the following information:\n\n```ts\ntype UseCustomPluginSignature = TreeViewPluginSignature<{\n  // The params specific to your plugin before running `getDefaultizedParams`\n  params: UseCustomPluginParams;\n  // The params specific to your plugins after running `getDefaultizedParams`\n  defaultizedParams: UseCustomPluginDefaultizedParams;\n  // The methods added to the Tree View instance by your plugin\n  instance: UseCustomPluginInstance;\n  // The events emitted by your plugin\n  events: UseCustomPluginEvents;\n  // The states defined by your plugin\n  state: UseCustomPluginState;\n  // The context value defined by your plugin and passed to the items\n  contextValue: UseCustomPluginContextValue;\n  // The slots used by this plugin\n  slots: UseCustomPluginSlots;\n  // The slot props used by this plugin\n  slotProps: UseCustomPluginSlotProps;\n  // The name of the models defined by your plugin\n  modelNames: UseCustomPluginModelNames;\n  // The plugins this plugin needs to work correctly\n  dependencies: UseCustomPluginDependantPlugins;\n}>;\n```\n\nThe most basic plugin would have the following signature:\n\n```ts\ntype UseCustomPluginSignature = TreeViewPluginSignature<{}>;\n```\n\nThe plugin built in the sections above would have the following signature:\n\n```ts\ntype UseCustomPluginSignature = TreeViewPluginSignature<{\n  params: {\n    customParam?: boolean;\n    customModel?: boolean;\n    defaultCustomModel?: boolean;\n  };\n  // `customParam` and `defaultCustomModel` have a default value defined in `getDefaultizedParams`\n  defaultizedParams: {\n    customParam: boolean;\n    customModel?: boolean;\n    defaultCustomModel: boolean;\n  };\n  instance: { toggleCustomModel: () => void };\n  events: {\n    toggleCustomModel: {\n      params: { value: boolean };\n    };\n  };\n  contextValue: { customPlugin: { enabled: boolean } };\n  modelNames: 'customModel';\n  // We want to have access to the expansion models and methods of the expansion plugin.\n  dependencies: [UseTreeViewExpansionSignature];\n}>;\n```"
          ],
          "code_path": [
            null
          ],
          "children": []
        }
      ]
    },
    {
      "name": "Examples",
      "introduction": [
        "Examples"
      ],
      "code_path": [
        null
      ],
      "children": [
        {
          "name": "Log expanded items",
          "introduction": [
            "Log expanded items\n\nInteract with the Tree View to see the expanded items being logged:"
          ],
          "code_path": [
            "LogExpandedItems.js"
          ],
          "children": []
        }
      ]
    }
  ]
}